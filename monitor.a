; memory map
; 0xxx - ram
; 10xx - io
; 11xx - rom

; io map
; 10xx xx00 xxxx xxxX - serial
; 10xx xx01 xxxx xxxX - i2c interface

; ram map
; 0000 -> 0fff - temp storage (stack at 0fff)
; 4000 -> 7fff - 16kb for rom when uploading
; rom map
; c000 -> ffff - program

; ascii constants

CR		equ $0d
LF		equ $0a
BS		equ $10
NULL		equ $00

; serial port addresses - for readability dupe the read/write locations

SERIALCR	equ $8000
SERIALRX	equ $8001
SERIALSR	equ $8000
SERIALTX	equ $8001

; i2c

I2CLOW		equ $8100
I2CHIGH		equ $8101

; memory

RAMSTART        equ $0000
RAMEND          equ $7fff
ROMSTART        equ $c000
ROMEND          equ $ffff
ROMCOPYSTART    equ $4000
ROMCOPYEND      equ $7fff

STACKEND	equ $0fff

PCOFFSET	equ 10

; software interrupt vector

		org $fffa

		fdb swinterrupt

; non maskable interupt vector

		org $fffc

		fdb nmiinterrupt

; setup the reset vector, last location in rom

		org $fffe
	
		fdb reset

; in ram, add our global variables

		org 0

userregs	rmb 11
inputbuffer	rmb 256
outputbuffer	rmb 256
parambuffer	rmb 256
dumpreadpointer	rmb 2
dumpreadcounter	rmb 2
flashblock	rmb 64
timeoutput	rmb 8
uptimeh		rmb 2
uptimel		rmb 2
; this is the start of rom

		org $c000

; START OF DATA

greetingmsg	fcb CR
		fcb LF
		fcc '6809 Monitor v0.0.3.'
		fcb CR
		fcb LF
		fcb CR
		fcb LF
		fcb NULL
youtypedmsg	fcc 'You typed: '
		fcb NULL
promptmsg	fcc 'Monitor: > '
		fcb NULL
nosuchmsg	fcc 'No such command'
		fcb CR
		fcb LF
		fcb NULL
commfailedmsg	fcc 'Command failed, possibly bad syntax'
		fcb CR
		fcb LF
		fcb NULL
breakatmsg	fcc '***Break at '
		fcb NULL
badexitmsg	fcc 'Internal error; leaving monitor'
		fcb CR
		fcb LF
		fcb NULL
flashreadymsg	fcc '+++'
		fcb NULL
resetmsg	fcb CR
		fcb LF
		fcc '***flash with f or any other key to start'
		fcb CR
		fcb LF
		fcb NULL
i2cbuserrormsg	fcc 'I2C bus error'
		fcb CR
		fcb LF
		fcb NULL
i2ctimeoutmsg	fcc 'I2C timeout'
		fcb CR
		fcb LF
		fcb NULL
helpmsg		fcc 'Commands:'
		fcb CR
		fcb LF
		fcc '  r : show registers'
		fcb CR
		fcb LF
		fcc '  w AAAA B1 B2 B3 ... : write to AAAA bytes B1 B2 B3 ...'
		fcb CR
		fcb LF
		fcc '  d AAAA LLLL : dump from AAAA count LLLL bytes in hex'
		fcb CR
		fcb LF
		fcc '  e EEEE : exit to user code at EEEE'
		fcb CR
		fcb LF
		fcc '  x : reset the monitor'
		fcb CR
		fcb LF
		fcc '  s SS [AA]AA FFFF LLLL: store to I2C slave SS at [AA]AA count LLL bytes'
		fcb CR
		fcb LF
		fcc '      reading from memory starting from FFFF'
		fcb CR
		fcb LF
		fcc '  l SS [AA]AA DDDD LLLL : load from I2C slave SS at [AA]AA count LLLL bytes'
		fcb CR
		fcb LF
		fcc '      and copy into memory starting from DDDD'
		fcb CR
		fcb LF
		fcc '  t : show time'
		fcb CR
		fcb LF
		fcc '  u : show uptime'
		fcb CR
		fcb LF
		fcc '  h or ? : this help'
		fcb CR
		fcb LF
		fcb CR
		fcb LF
		fcb NULL

ccmsg		fcc 'CC: '
		fcb NULL
amsg		fcc '  A: '
		fcb NULL
bmsg		fcc '  B: '
		fcb NULL
dpmsg		fcc '  DP: '
		fcb NULL
xmsg		fcc '  X: '
		fcb NULL
ymsg		fcc '  Y: '
		fcb NULL
umsg		fcc '  U: '
		fcb NULL
pcmsg		fcc '  PC: '
		fcb NULL

newlinemsg	fcb CR
		fcb LF
		fcb NULL

; commandarray - subroutine address followed by command letter code

commandarray	fdb dumpmemory
		fcc 'd'
		fdb writememory
		fcc 'w'
		fdb exitmonitor
		fcc 'e'
		fdb showregisters
		fcc 'r'
		fdb showhelp
		fcc 'h'
		fdb showhelp
		fcc '?'			; same command different letter
		fdb resetmonitor
		fcc 'x'
		fdb i2cstore
		fcc 's'
		fdb i2cload
		fcc 'l'
		fdb showtime
		fcc 't'
		fdb showuptime
		fcc 'u'
		fdb $0000
		fcb NULL

; showtimeparams - params for i2cload for reading the time into timeoutput buffer

showtimeparams	fcb 1
		fcb $d0
		fcb 1
		fcb $00
		fcb 2
		fdb timeoutput
		fcb 2
		fdb $0008
		fcb 0

; days array - each day is 4 bytes long

days		fcc 'Sun'
		fcb NULL
		fcc 'Mon'
		fcb NULL
		fcc 'Tue'
		fcb NULL
		fcc 'Wed'
		fcb NULL
		fcc 'Thu'
		fcb NULL
		fcc 'Fri'
		fcb NULL
		fcc 'Sat'
		fcb NULL

; END OF DATA

; setup stack to the end of ram so it can go grown backwards

reset		lds #STACKEND+1		; setup hardware stack

		ldx #RAMSTART		; clear from start of ram
zeroram		clr ,x+
		cmpx #RAMEND+1		; to end
		bne zeroram

; setup the serial port

		lbsr serialinit		; setup the serial port

		ldx #resetmsg		; show prompt for flash
		lbsr serialputstr

		lbsr serialgetchar	; wait for a key, getting the command

		cmpa #$66		; 'f'
		bne normalstart		; not one? then normal startup

		ldx #ROMSTART		; setup the rom copy to ram
		ldy #ROMCOPYSTART	; this is the second half of ram
romcopy		lda ,x+			; read in
		sta ,y+			; and read out
		cmpx #ROMEND+1		; check to see if we are at the end
		bne romcopy		; copy more

		ldx #flasher		; get the location of the flasher code
		leax -ROMSTART,x	; offset it from the start of rom
		leax ROMCOPYSTART,x	; offset it forward where it now is 
		jmp ,x			; jump to the new location of flasher

normalstart	ldx #greetingmsg	; greetings!
		lbsr serialputstr	; output the greeting

		clra			; reset uptime
		clrb			; both bytes
		std uptimeh		; and store high word
		std uptimel		; and low word

		lbsr i2cinit		; setup i2c

		swi			; enter the monitor (mainloop)

; we should never get here - it means rti was done without fixing up
; the return address, print error and loop

		ldx #badexitmsg		; if we get here then setup a msg
		lbsr serialputstr	; print the message
badexitloop	bra badexitloop		; loop on the spot

; nmi uptime counter

nmiinterrupt	ldx uptimel
		leax 1,x
		stx uptimel
		bne nmiinterruptout
		ldx uptimeh
		leax 1,x
		stx uptimeh
nmiinterruptout	rti

; monitor entry point

swinterrupt	ldx #outputbuffer	; setup the "break" message
		ldy #breakatmsg		; ...
		lbsr concatstr		; append it
		leay ,s			; get the new stack pointr
		ldd 10,y		; the pc is 10 bytes in
		lbsr wordtoaschex	; convert it to ascii
		ldy #newlinemsg		; adding a newline
		lbsr concatstr		; append it
		clr ,x+			; add a null

		ldx #outputbuffer	; reset the string pointer
		lbsr serialputstr	; so it can be output

mainloop	ldx #promptmsg		; ">" etc
		lbsr serialputstr	; output that
		
		ldx #inputbuffer	; now we need a command
		lbsr serialgetstr	; get the command (waiting as needed)

		ldx #outputbuffer

		ldy #newlinemsg		; tidy up the console with a newline
		lbsr concatstr		; ...

		ldy #youtypedmsg	; tell the user ...
		lbsr concatstr		; ...
		ldy #inputbuffer	; ...
		lbsr concatstr		; ...
		ldy #newlinemsg		; ...
		lbsr concatstr		; ...
		clr ,x+			; (add a null)

		ldx #outputbuffer
		lbsr serialputstr	; ... what they typed

		lda inputbuffer		; get the first char
		ldx #commandarray	; setup the command pointer
nextcommand	ldy ,x++		; get the sub address
		ldb ,x			; get the command letter
		beq commandarrayend	; end of command list?
		cmpa ,x+		; compare input letter with array item
		bne nextcommand		; no match? check next one
		jsr ,y			; jump to subroutine
		bne commanderror	; error check for zero
		bra mainloop		; back to top
commanderror	ldx #commfailedmsg
		lbsr serialputstr	; show error
		bra mainloop

commandarrayend	ldx #nosuchmsg
		lbsr serialputstr	; show error message
		bra mainloop

;;; COMMANDS ;;;

; dumpmemory - "d AAAA BBBB" - dumps from AAAA, BBBB bytes
;
; C000  48 65 6C 6C 6F 2C 20 74  68 69 73 20 69 73 20 61  [Hello, this is a]

dumpmemory	lbsr parseinput		; parse hexes, filling out inputbuffer
		lda ,y+			; get the type
		cmpa #2			; is it a word?
		lbne dumpmemoryerror	; validation error
		ldd ,y++		; start address
		andb #$f0		; round to nearest 16
		std dumpreadpointer	; store it in the variable
		lda ,y+			; get the type
		cmpa #2			; is it a word?
		bne dumpmemoryerror	; yes, mark it as bad
		ldd ,y++		; length/count of bytes
		andb #$f0		; also rounded
		std dumpreadcounter	; store it in the variable

dumpnextrow	ldx #outputbuffer	; x is persistent across the whole row

		ldd dumpreadpointer	; get address of this row
		lbsr wordtoaschex	; print the address into the buffer
		lda #$20		; space
		sta ,x+			; add a space after the address
		sta ,x+			; and another

; hex version

		ldy dumpreadpointer	; points at the start of the row
		ldb #0			; counts across 16 bytes

hexbyteloop	cmpb #$08		; for pretty ness...
		bne noextraspace	; add a space after 8 bytes
		lda #$20		; space
		sta ,x+			; push it in
noextraspace	lda b,y			; actually read the byte from memory
		lbsr bytetoaschex	; convert it to ascii
		lda #$20		; space
		sta ,x+			; add a space between each byte
		incb			; incrememnt offset
		cmpb #$10		; 16 bytes per row
		bne hexbyteloop		; and do the next byte

		lda #$20		; spaces
		sta ,x+			; add it in
		lda #$5b		; opening [
		sta ,x+			; add it in

; ascii version

		ldy dumpreadpointer	; reset back to the start of the row
		ldb #0			; counts across 16 bytes

ascbyteloop	lda b,y			; get the byte from memory
		lbsr printableasc	; nonprintable to a dot
		sta ,x+			; add it in
		incb			; increment offset
		cmpb #$10		; 16 bytes per row
		bne ascbyteloop		; and do the next byte

		lda #$5d		; closing ]
		sta ,x+			; add it in

		clra ,x+		; null terminator

		ldx #outputbuffer	; reset back to the start
		lbsr serialputstr	; so we can finally output it!

		ldx #newlinemsg		; newline
		lbsr serialputstr	; output it

; move onto the the next row

		ldx dumpreadpointer	; load the pointer back in
		leax $10,x		; add $10
		stx dumpreadpointer	; store it back
		ldx dumpreadcounter	; loead the remaning byte counter
		leax -$10,x		; subtract $10
		stx dumpreadcounter	; store it back

		bne dumpnextrow		; more rows?
		clra			; no error
		rts
dumpmemoryerror	lda #1			; mark zero for error
		rts

writememory	lbsr parseinput		; parse hexes, filling out inputbuffer
		lda ,y+			; get the type
		cmpa #2			; is it a word?
		lbne writememoryerr	; validation error
		ldx ,y++		; start address
nextwritebyte	lda ,y+			; get the type
		beq writememoryout	; that's the end of the byte list
		cmpa #1			; is it a byte?
		bne writememoryerr	; not a byte, so error
		ldb ,y+			; get the byte to write
		stb ,x+			; and load it at memory x
		bra nextwritebyte	; back for more
writememoryerr	lda #1			; error condition
		rts
writememoryout	clra			; clean exit
		rts

; exitmonitor - fixup return address and leave monitor

exitmonitor	lbsr parseinput		; parse hexes, filling out inputbuffer
		lda ,y+			; get the type
		cmpa #2			; is it a word?
		lbne exitmonitorerr	; validation error
		lds #STACKEND+1		; move the stack to the top
		leas -12,s		; then move it back one frame
		ldx ,y++		; sub address
		beq cleanexit		; if exit address is 0 dont modify
		stx 10,s		; before modifiying the pc in stack
cleanexit	rti			; run the usercode at that address
exitmonitorerr	lda #1
		rts	

; shows the registers as they were when the monitor was entered

showregisters	ldx #outputbuffer	; set output buffer

		ldy #ccmsg		; get the 'C: '
		lbsr concatstr		; concat it onto outputbuffer
		lda STACKEND+1-12	; get the register value
		lbsr bytetoaschex	; convert and concat it

		ldy #amsg		; same again
		lbsr concatstr		; ...
		lda STACKEND+1-11	; ...
		lbsr bytetoaschex	; ...

		ldy #bmsg
		lbsr concatstr
		lda STACKEND+1-10
		lbsr bytetoaschex

		ldy #dpmsg
		lbsr concatstr
		lda STACKEND+1-9
		lbsr bytetoaschex

		ldy #xmsg
		lbsr concatstr
		ldd STACKEND+1-8
		lbsr wordtoaschex

		ldy #ymsg
		lbsr concatstr
		ldd STACKEND+1-6
		lbsr wordtoaschex

		ldy #umsg
		lbsr concatstr
		ldd STACKEND+1-4
		lbsr wordtoaschex

		ldy #pcmsg
		lbsr concatstr
		ldd STACKEND+1-2
		lbsr wordtoaschex

		ldy #newlinemsg
		lbsr concatstr
		clr ,x+

		ldx #outputbuffer	; and output it
		lbsr serialputstr
		clra			; we always succeed
		rts

; i2c store - "s SS [AA]AA FFFF LLLL..." - writes to the i2c bus

i2cstore	lbsr parseinput		; parse hexes, filling out inputbuffer

i2cstoredirect	lbsr i2caddr		; send the i2c and memory addresses
		bne i2cstoreerr		; validation error from the above

		lda ,y+			; get the type
		cmpa #2			; word?
		bne i2cstoreerr		; validation error
		ldx ,y++		; get the start of mpu memory

		lda, y+			; get the type
		cmpa #2			; word?
		bne i2cstoreerr		; validation error
		ldy ,y			; get the count of bytes to read

i2cstorenext	lbsr i2csenddone	; wait for last byte
		bne i2cstorebuserr	; i2c bus error
		lda ,x+			; get data to write
		lbsr i2cwrite		; write it

		leay -1,y
		bne i2cstorenext	; look for more

		lbsr i2csenddone	; wait for last write to finish
		bne i2cstorebuserr	; i2c bus error
		lbsr i2cstop		; mark with stop code
		clra
		rts

i2cstorebuserr	ldx #i2cbuserrormsg
		lbsr serialputstr	; tell the user about the bus error
		lbsr i2cstop
		lda #1			; this is not a validation error
		rts

i2cstoreerr	lbsr i2cstop		; tidy up with a stop
		lda #1			; bad exit
		rts

; i2cload - "l SS [AA]AA LLLL DDDD" - copy from i2c to ram

i2cload		lbsr parseinput		; parse commandline into y

; i2cloaddirect - direct entry to do a load with params stored at y

i2cloaddirect	tfr y,x			; save y so we can restore it
		lbsr i2caddr		; send the address
		bne i2cstoreerr		; validation error

		lbsr i2csenddone	; wait for last byte read
		bne i2cloadbuserr	; i2c bus error

		tfr x,y			; reset the parser pointer

		lda ,y+			; skip the type

		lbsr i2crepeatstart	; special repeat start for control

		lda ,y+			; get the slave address
		ora #1			; r/w bit to high for read
		lbsr i2cwrite		; send the read slave address

		lda ,y+			; get the type
		leay a,y		; skip memory address; already sent

		lda ,y+			; get the type
		cmpa #2			; word?
		bne i2cloaderr		; validation error
		ldx ,y++		; get the start of mpu memory

		lda, y+			; get the type
		cmpa #2			; word?
		bne i2cloaderr		; validation error
		ldy ,y			; get the count of bytes to read
		leay -1,y		; sub 1 for the special read

		lbsr i2cread		; this will return slave address
					; ignore it

		lbsr i2csenddone	; wait for last byte read
		bne i2cloadbuserr	; i2c bus error

		lbsr i2cread		; read the slave addres again
					; again ignore it

		leay ,y			; see if we don't have to loop at all...
		beq i2cloadoutloop	; because we are reading a single byte

i2cloadnext	lbsr i2csenddone	; wait for the last byte to go
		bne i2cloadbuserr	; bus error?

		leay -1,y
		beq i2cloadoutloop	; done?

		lbsr i2cread		; read the i2c byte!

		sta ,x+			; store the byte and advance

		bra i2cloadnext		; get more

; last byte is special - we have one more byte to read

i2cloadoutloop	lbsr i2cnack		; negative ack for last byte

		lbsr i2cread		; dummy read, dont store
		sta ,x+			; save it to ram

		lbsr i2csenddone	; wait for the pernultimate byte
					; ignore errors on last byte

		lbsr i2cstop		; send the stop

		lbsr i2cread		; the real last read
		sta ,x+			; save it to ram

		clra			; good exit
		rts

i2cloadbuserr	ldx #i2cbuserrormsg	; error message
		lbsr serialputstr	; print it
		lbsr i2cstop
		lda #1			; bad exit
		rts

i2cloaderr	lbsr i2cstop		; tidy up with a stop
		lda #1			; bad exit
		rts

; shows some help text

showhelp	ldx #greetingmsg	; show the greeting
		lbsr serialputstr	; for the version number
		ldx #helpmsg		; and the help text
		lbsr serialputstr
		clra			; we always suceed
		rts

; restart the monitor (so we can flash it with 'f', most likely)

resetmonitor	ldx $fffe		; get the reset vector
		jmp ,x			; jump to it

; time

showtime	ldy #showtimeparams	; setup param block for i2c to rtc

		lbsr i2cloaddirect	; do the i2c operation

		ldx #outputbuffer	; setup output buffer
		ldy #timeoutput		; setup rtc data buffer

		lda 2,y			; get hours
		lbsr bytetoaschex	; render hex into x
		lda #$3a		; ':'
		sta ,x+	
		lda 1,y			; get minutes
		lbsr bytetoaschex
		lda #$3a		; ':'
		sta ,x+
		lda 0,y			; get seconds
		lbsr bytetoaschex
		lda #$20		; space char
		sta ,x+
		clra			; add a null
		sta ,x+
		ldx #outputbuffer	; reset x for printing
		lbsr serialputstr	; print the time followed by space

		lda 3,y			; get days (1-7)
		deca			; make it into 0-6
		lsla			; multiple by 4 as each day is 4...
		lsla			; bytes including a null
		ldx #days		; setup pointer to day array
		leax a,x		; add on the offset from above
		lbsr serialputstr	; output the day

		ldx #outputbuffer	; back in the ram buffer
		lda #$20		; space char
		sta ,x+			; add it so its after the day
		lda 4,y			; get date in month
		lbsr bytetoaschex
		lda #$2f		; '/'
		sta ,x+
		lda 5,y			; get the month
		lbsr bytetoaschex
		lda #$2f		; '/'
		sta ,x+
		lda 6,y			; get the year
		lbsr bytetoaschex
		clra
		sta ,x+
		ldx #outputbuffer	; reset output buffer
		lbsr serialputstr	; output the date ( DD/MM/YY)

		ldx #newlinemsg
		lbsr serialputstr	; and add a newline

		clra
		rts		

; showuptime

showuptime	ldx #outputbuffer
		ldd uptimeh
		lbsr wordtoaschex
		ldd uptimel
		lbsr wordtoaschex
		ldy #newlinemsg
		lbsr concatstr
		clr ,x+
		ldx #outputbuffer
		lbsr serialputstr
		rts

;;; SERIAL PORT ;;;

; serial port setup

serialinit	lda #%00000011		; master reset
		sta SERIALCR
		; divider (=16), databits (=8n1), no rts and no interrupts
		lda #%00010101
		sta SERIALCR
		rts

; put the char in a, returning when its sent - corrupts b

serialputchar	ldb SERIALSR
		andb #%00000010		; transmit empty
		beq serialputchar	; wait for port to be idle
		sta SERIALTX		; output the char
		rts

; puts the null terminated string pointed to by x

serialputstr	lda ,x+			; get the next char
		beq serialputstrout	; null found, bomb out
		bsr serialputchar	; output the character
		bra serialputstr	; more chars
serialputstrout	rts

; serialgetchar - gets a char, putting it in a

serialgetchar 	lda SERIALSR		; get status
		anda #%00000001		; input empty?
		beq serialgetchar	; go back and look again
		lda SERIALRX		; get the char into a
serialgetcharo	rts
		
; serialgetstr - gets a line, upto a cr, filling x as we go

serialgetstr	bsr serialgetchar	; get a char in a
		cmpa #CR		; cr?
		beq serialgetstrout	; if it is, then out
		cmpa #LF		; lf?
		beq serialgetstrout	; if it is, then out
		bsr serialputchar	; echo it
		sta ,x+			; add it to string
		bra serialgetstr	; get more
serialgetstrout	clr ,x+			; add a null
		rts

;;; I2C ;;;

i2cinit		lda #$80		; for reg S0' which is our address
		sta I2CHIGH
		lda #$55
		sta I2CLOW		; store $55 (own address = $aa)
		lda #$a0		; for reg S1
		sta I2CHIGH
		lda #%00011100
		sta I2CLOW		; clock = 12mhz, scl freq = 90khz
		lda #$c1
		sta I2CHIGH		; enable i2c
		rts

i2cdelay	pshs y
		ldy #$8000
		lbsr delay
		puls y
		rts

i2cbusbusycheck	pshs x
		ldx #$2000
i2cbusbusypoll	leax -1,x
		beq i2cbusbusyto
		lda I2CHIGH		; get status
		bita #1			; check busy bit
		beq i2cbusbusypoll	; fall through when busy bit is 1
		clra
		puls x
		rts
i2cbusbusyto	ldx #i2ctimeoutmsg
		lbsr serialputstr
		lda #1
		puls x
		rts

i2csenddone	pshs x
		ldx #$4000
i2csendpoll	leax -1,x
		beq i2csendtimeout
		lda I2CHIGH
		bita #$80
		bne i2csendpoll
		bita #$0a		; clears z if i2c bus error
		puls x
		rts
i2csendtimeout	ldx #i2ctimeoutmsg
		lbsr serialputstr
		lda #1
		puls x
		rts
		
i2cstart	lda #$c5
		sta I2CHIGH		; send start
		rts

i2crepeatstart	lda #$45
		sta I2CHIGH		; repeat start
		rts

i2cstop		lda #$c3
		sta I2CHIGH		; send stop
		rts

i2cnack		lda #$40
		sta I2CHIGH		; send nack
		rts

i2cack		lda #41			; send ack
		sta I2CHIGH
		rts

i2cwrite	sta I2CLOW		; send data
		rts

i2cread		lda I2CLOW		; read data
		rts

; i2caddr - midlayer sub for for sending i2c addr and memory addr

i2caddr		lda ,y+			; get the type
		cmpa #1			; is it a word?
		bne i2caddrerr		; validation error

		lbsr i2cbusbusycheck	; wait for bus availability
		bne i2caddrbuserr	; i2c bus busy timeout

		lda ,y+			; get the slave address
		bsr i2cwrite		; set the slave address

		bsr i2cstart		; start of the transfer

		bsr i2csenddone
		bne i2caddrbuserr	; i2c bus error

		ldb ,y+			; get the type

i2caddrnext	lda ,y+			; read address, high in a
		bsr i2cwrite

		bsr i2csenddone
		bne i2caddrbuserr	; i2c bus error

		decb
		bne i2caddrnext

i2caddrout	clra
		rts

i2caddrbuserr	ldx #i2cbuserrormsg	; bus error message
		lbsr serialputstr	; show it
		lda #1			; still a clean exit though
		rts

i2caddrerr	bsr i2cstop		; tidy up with a stop
		lda #1			; bad exit
		rts

;;; STRINGS ;;;

; aschextonib - convert a char on x to a low nibble in a

aschextonib	lda ,x+			; get the charater
		suba #$30		; subtract '0'
		cmpa #$10		; less then 9?
		blo aschextonibout	; yes? we are done
		suba #$07		; no? subtract 'A'-'9'
		cmpa #$10		; less then 16?
		blo aschextonibout	; was uppercase
		suba #$20
aschextonibout	rts

; aschextobyte - convert two characters on x to a byte in a

aschextobyte	leas -1,s		; make room on stack for 1 temp byte
		bsr aschextonib		; convert the low nibble
		lsla			; make it the high nibble
		lsla			; ..
		lsla			; ..
		lsla			; ..
		sta ,s			; save it on the stack
		bsr aschextonib		; convert the real low nibble
		ora ,s			; combine it with the high nibble
		leas 1,s		; shrink the stack again
		rts

; aschextowrd - convert four characters on x to a word in d

aschextoword	bsr aschextobyte	; convert the first byte in the string
		tfr a,b			; move it asside
		bsr aschextobyte	; convert the second byte
		exg a,b			; swap the bytes
		rts			; d is now the word

; parse a stream of ascii hex into the u stack

parseinput	ldx #inputbuffer+1	; point at the inputbuffer
		ldy #parambuffer	; setup parser location
nextparseinput	lda ,x			; check for an initiial null
		beq parseinputout	; null? out we go
		bsr skipspaces		; skip spaces
		lda 2,x			; get the next but one char
		beq parsebyte		; null? it's a byte
		cmpa #$20		; space
		beq parsebyte		; yes? it's a byte
		bra parseword		; must be a word
parsebyte	lda #1			; code 1 for bytes
		sta ,y+			; add it into the stream
		bsr aschextobyte	; yes? this pair must be a byte
		sta ,y+			; save it in u
		bra nextparseinput		; look for more
parseword	lda #2			; code 2 for words
		sta ,y+			; add it in to the stream
		bsr aschextoword	; if we get here it must be a word
		std ,y++		; save the word in u
		bra nextparseinput
parseinputout	clr ,y+			; null ender
		ldy #parambuffer	; reset back for the caller
		rts

; nibtoaschex - convert a low nibble in a to a character in x, advancing it

nibtoaschex	anda #$0f		; mask out the high nibble
		adda #$30		; add '0'
		cmpa #$39		; see if we are past '9'
		ble nibtoaschexout	; no? number then, so we're done
		adda #$07		; yes? letter then, add 'A'-'9'
nibtoaschexout	sta ,x+			; add it to the string
		rts		

; bytetoaschex - convert a byte in a to two characters in x, advancing it
		
bytetoaschex	pshs a			; save original input byte
		lsra			; move high nibble into low nibble
		lsra			; ..
		lsra			; ..
		lsra			; ..
		bsr nibtoaschex		; convert the low nibble
		puls a			; get the original input back
		bsr nibtoaschex		; convert the high nibble
		rts

; wordtoaschex - convert a word in d to four characters in x, advancing it

wordtoaschex	pshs b			; save low byte
		bsr bytetoaschex	; output high byte
		puls a			; restore low byte
		bsr bytetoaschex	; and output low byte
		rts

; jump x across spaces

skipspaces	lda ,x+			; skip a space
		cmpa #$20		; is it a space?
		beq skipspaces		; yes? then go back and look for more
		leax -1,x		; back 1
		rts

; printableasc - converts non printables to . in a

printableasc	cmpa #$20		; compare with space
		blo printabletodot	; lower? it must be a unprintable
		cmpa #$7e		; compare with the end char
		bhi printabletodot	; higher? it must be unprintable
		rts			; if not, leave it alone
printabletodot	lda #$2e		; otherwise flatten it to a dot
		rts

; concatstr - add string y to string x, not copying the null

concatstr	lda ,y+			; get the char in y
		beq concatstrout	; if its a null then finish
		sta ,x+			; otherwise add it to x
		bra concatstr		; go back for more
concatstrout	rts

;;; MISC ;;;

; delay by y - subroutine

delay		leay -1,y		; decrement y
		bne delay		; not zero? do it again
		rts
; flasher

flasher		ldx #flashreadymsg	; tell other end it can send now
		lbsr serialputstr

; read 64bytes from the serial port into ram

		ldy #ROMSTART		; setup the counter into rom
inflashblk	ldx #flashblock		; this is the block in ram we...
		ldb #64			; are copying into
inflash		lbsr serialgetchar	; get the byte from the port
		sta ,x+			; store it
		decb			; we store 64bytes
		bne inflash		; back to the next byte

; then write them into rom

		ldx #flashblock		; after we have a block
		ldb #64			; of 64 bytes
outflash	lda ,x+			; get the byte from ram
		sta ,y+			; and write it into the rom
		decb			; reduce byte counter
		bne outflash		; back for more if non zero

; circa 10ms delay between blocks

		ldx #12000		; setup delay counter
flashdelayloop	leax -1,x		; dey
		bne flashdelayloop

; tell the uploader that we have written the block, and it can send the
; next one

		lda #$23		; '#'
		lbsr serialputchar	; send the char
		cmpy #ROMEND+1		; see if we are the end of rom
		bne inflashblk		; back to the next block

; send the content of the rom back, so the sender knows what was written -
; we can't do anything if it didn't write, but at least we know

		ldy #ROMSTART		; back to the start
verflash	lda ,y+			; get the byte
		lbsr serialputchar	; output it
		cmpy #ROMEND+1
		bne verflash

; we could in theory try again but good or bad, do a reset on the new
; reset vector
		
		ldx $fffe		; load the new reset vector
		jmp ,x			; jump to it
