; memory map
; 0xxx - ram
; 10xx - io
; 11xx - rom

; io map
; 10xx x000 xxxx xxxX - serial
; 10xx x001 xxxx xxxX - unused
; 10xx x010 xxxx xxxx - simple diagnostic latch
; 10xx x011 xxxx XXXX - 6522
; 10xx x100 xxxx xXXX - ide port

; ram map
; 0000 -> 0fff - temp storage (stack at 0fff)
; 4000 -> 7fff - 16kb for rom when uploading
; rom map
; c000 -> ffff - program

; ascii constants

CR		equ $0d
LF		equ $0a
BS		equ $10
NULL		equ $00

; serial port addresses - for readability dupe the read/write locations

SERIALCR	equ $8000
SERIALRX	equ $8001
SERIALSR	equ $8000
SERIALTX	equ $8001

; latch

LATCH		equ $8200

; 6522

PORTB6522	equ $8300
PORTA6522	equ $8301
DDRB6522	equ $8302
DDRA6522	equ $8303
T1CL6522	equ $8304
T1CH6522	equ $8305
T1LL6522	equ $8306
T1LH6522	equ $8307
T2LL6522	equ $8308
T2CL6522	equ $8308
T2CH6522	equ $8309
SR6522		equ $830a
ACR6522		equ $830b
PCR6522		equ $830c
IFR6522		equ $830d
IER6522		equ $830e
ORAX6522	equ $830f

; IDE

IDEDATA		equ $8400
IDEERR		equ $8401
IDEFEATURES	equ $8401
IDECOUNT	equ $8402
IDELBA0		equ $8403
IDELBA1		equ $8404
IDELBA2		equ $8405
IDELBA3		equ $8406
IDEHEADS	equ $8406
IDESTATUS	equ $8407
IDECOMMAND	equ $8407

; memory

RAMSTART        equ $0000
RAMEND          equ $7fff
ROMSTART        equ $c000
ROMEND          equ $ffff
ROMCOPYSTART    equ $4000
ROMCOPYEND      equ $7fff

STACKEND	equ $0fff

PCOFFSET	equ 10

; SPI bits

MOSI		equ $01
SCLK 		equ $02
SS		equ $04
MISO		equ $80

; software interrupt vector

		org $fffa

		fdb swinterrupt

; non maskable interupt vector

		org $fffc

		fdb nmiinterrupt

; setup the reset vector, last location in rom

		org $fffe
	
		fdb reset

; in ram, add our global variables

		org 0

userregs	rmb 11
inputbuffer	rmb 256
outputbuffer	rmb 256
parambuffer	rmb 256
dumpreadpointer	rmb 2
dumpreadcounter	rmb 2
flashblock	rmb 64
timeoutput	rmb 8
uptimeh		rmb 2
uptimel		rmb 2
ideidentifyblk	rmb 512
idembrblk	rmb 512
firstpartsects	rmb 2

; this is the start of rom

		org $c000

; START OF GLOBAL READ-ONLY DATA

greetingmsg	fcb CR
		fcb LF
		fcc '6809 Monitor v0.0.5.'
		fcb CR
		fcb LF
		fcb CR
		fcb LF
		fcb NULL
youtypedmsg	fcc 'You typed: '
		fcb NULL
promptmsg	fcc 'Monitor: > '
		fcb NULL
nosuchmsg	fcc 'No such command'
		fcb CR
		fcb LF
		fcb NULL
commfailedmsg	fcc 'Command failed, possibly bad syntax'
		fcb CR
		fcb LF
		fcb NULL
breakatmsg	fcc '***Break at '
		fcb NULL
badexitmsg	fcc 'Internal error; leaving monitor'
		fcb CR
		fcb LF
		fcb NULL
flashreadymsg	fcc '+++'
		fcb NULL
resetmsg	fcb CR
		fcb LF
		fcc '***flash with f or any other key to start'
		fcb CR
		fcb LF
		fcb NULL

newlinemsg	fcb CR
		fcb LF
		fcb NULL

; commandarray - subroutine address followed by command letter code

commandarray	fdb dumpmemory
		fcc 'd'
		fdb writememory
		fcc 'w'
		fdb exitmonitor
		fcc 'e'
		fdb showregisters
		fcc 'r'
		fdb showhelp
		fcc 'h'
		fdb showhelp
		fcc '?'			; same command different letter
		fdb resetmonitor
		fcc 'x'
		fdb showtime
		fcc 't'
		fdb showuptime
		fcc 'u'
		fdb latchout
		fcc 'c'
		fdb spistore
		fcc '+'
		fdb ideidentify
		fcc 'i'
		fdb idereadsector
		fcc '<'
		fdb readblock
		fcc 'b'
		fdb idemount
		fcc 'm'
		fdb $0000
		fcb NULL


; END OF DATA

; setup stack to the end of ram so it can go grown backwards

reset		lds #STACKEND+1		; setup hardware stack

		ldx #RAMSTART		; clear from start of ram
zeroram		clr ,x+
		cmpx #RAMEND+1		; to end
		bne zeroram

; setup the serial port

		lbsr serialinit		; setup the serial port
		lbsr viainit

		ldx #resetmsg		; show prompt for flash
		lbsr serialputstr

		lbsr serialgetchar	; wait for a key, getting the command

		cmpa #$66		; 'f'
		bne normalstart		; not one? then normal startup

		ldx #ROMSTART		; setup the rom copy to ram
		ldy #ROMCOPYSTART	; this is the second half of ram
romcopy		lda ,x+			; read in
		sta ,y+			; and read out
		cmpx #ROMEND+1		; check to see if we are at the end
		bne romcopy		; copy more

		ldx #flasher		; get the location of the flasher code
		leax -ROMSTART,x	; offset it from the start of rom
		leax ROMCOPYSTART,x	; offset it forward where it now is 
		jmp ,x			; jump to the new location of flasher

normalstart	ldx #greetingmsg	; greetings!
		lbsr serialputstr	; output the greeting

		clra			; reset uptime
		clrb			; both bytes
		std uptimeh		; and store high word
		std uptimel		; and low word

		swi			; enter the monitor (mainloop)

; we should never get here - it means rti was done without fixing up
; the return address, print error and loop

		ldx #badexitmsg		; if we get here then setup a msg
		lbsr serialputstr	; print the message
badexitloop	bra badexitloop		; loop on the spot

; nmi uptime counter - increment 32 bit counter

nmiinterrupt	ldx uptimel		; get current lowword uptime
		leax 1,x		; add 1
		stx uptimel		; store it back
		bne nmiinterruptout	; if not 0 then done
		ldx uptimeh		; otherwise low current highword
		leax 1,x		; add 1
		stx uptimeh		; store it back
nmiinterruptout	rti

; monitor entry point

swinterrupt	ldx #outputbuffer	; setup the "break" message
		ldy #breakatmsg		; ...
		lbsr concatstr		; append it
		leay ,s			; get the new stack pointr
		ldd 10,y		; the pc is 10 bytes in
		lbsr wordtoaschex	; convert it to ascii
		ldy #newlinemsg		; adding a newline
		lbsr concatstr		; append it
		clr ,x+			; add a null

		ldx #outputbuffer	; reset the string pointer
		lbsr serialputstr	; so it can be output

mainloop	ldx #promptmsg		; ">" etc
		lbsr serialputstr	; output that
		
		ldx #inputbuffer	; now we need a command
		lbsr serialgetstr	; get the command (waiting as needed)

		ldx #outputbuffer

		ldy #newlinemsg		; tidy up the console with a newline
		lbsr concatstr		; ...

		ldy #youtypedmsg	; tell the user ...
		lbsr concatstr		; ...
		ldy #inputbuffer	; ...
		lbsr concatstr		; ...
		ldy #newlinemsg		; ...
		lbsr concatstr		; ...
		clr ,x+			; (add a null)

		ldx #outputbuffer
		lbsr serialputstr	; ... what they typed

		lda inputbuffer		; get the first char
		ldx #commandarray	; setup the command pointer
nextcommand	ldy ,x++		; get the sub address
		ldb ,x			; get the command letter
		beq commandarrayend	; end of command list?
		cmpa ,x+		; compare input letter with array item
		bne nextcommand		; no match? check next one
		jsr ,y			; jump to subroutine
		bne commanderror	; error check for zero
		bra mainloop		; back to top
commanderror	ldx #commfailedmsg
		lbsr serialputstr	; show error
		bra mainloop

commandarrayend	ldx #nosuchmsg
		lbsr serialputstr	; show error message
		bra mainloop

; general error handler branch for commands that fail

generalerror	lda #1
		rts

;;; COMMANDS ;;;

; dumpmemory - "d AAAA BBBB" - dumps from AAAA, BBBB bytes
;
; C000  48 65 6C 6C 6F 2C 20 74  68 69 73 20 69 73 20 61  [Hello, this is a]

dumpmemory	lbsr parseinput		; parse hexes, filling out inputbuffer
		lda ,y+			; get the type
		cmpa #2			; is it a word?
		lbne generalerror	; validation error
		ldd ,y++		; start address
		andb #$f0		; round to nearest 16
		std dumpreadpointer	; store it in the variable
		lda ,y+			; get the type
		cmpa #2			; is it a word?
		bne generalerror	; yes, mark it as bad
		ldd ,y++		; length/count of bytes
		andb #$f0		; also rounded
		std dumpreadcounter	; store it in the variable

dumpnextrow	ldx #outputbuffer	; x is persistent across the whole row

		ldd dumpreadpointer	; get address of this row
		lbsr wordtoaschex	; print the address into the buffer
		lda #$20		; space
		sta ,x+			; add a space after the address
		sta ,x+			; and another

; hex version

		ldy dumpreadpointer	; points at the start of the row
		ldb #0			; counts across 16 bytes

hexbyteloop	cmpb #$08		; for pretty ness...
		bne noextraspace	; add a space after 8 bytes
		lda #$20		; space
		sta ,x+			; push it in
noextraspace	lda b,y			; actually read the byte from memory
		lbsr bytetoaschex	; convert it to ascii
		lda #$20		; space
		sta ,x+			; add a space between each byte
		incb			; incrememnt offset
		cmpb #$10		; 16 bytes per row
		bne hexbyteloop		; and do the next byte

		lda #$20		; spaces
		sta ,x+			; add it in
		lda #$5b		; opening [
		sta ,x+			; add it in

; ascii version

		ldy dumpreadpointer	; reset back to the start of the row
		ldb #0			; counts across 16 bytes

ascbyteloop	lda b,y			; get the byte from memory
		lbsr printableasc	; nonprintable to a dot
		sta ,x+			; add it in
		incb			; increment offset
		cmpb #$10		; 16 bytes per row
		bne ascbyteloop		; and do the next byte

		lda #$5d		; closing ]
		sta ,x+			; add it in

		clr ,x+			; null terminator

		ldx #outputbuffer	; reset back to the start
		lbsr serialputstr	; so we can finally output it!

		ldx #newlinemsg		; newline
		lbsr serialputstr	; output it

; move onto the the next row

		ldx dumpreadpointer	; load the pointer back in
		leax $10,x		; add $10
		stx dumpreadpointer	; store it back
		ldx dumpreadcounter	; loead the remaning byte counter
		leax -$10,x		; subtract $10
		stx dumpreadcounter	; store it back

		bne dumpnextrow		; more rows?
		clra			; no error
		rts

writememory	lbsr parseinput		; parse hexes, filling out inputbuffer
		lda ,y+			; get the type
		cmpa #2			; is it a word?
		lbne generalerror	; validation error
		ldx ,y++		; start address
nextwritebyte	lda ,y+			; get the type
		beq writememoryout	; that's the end of the byte list
		cmpa #1			; is it a byte?
		lbne generalerror	; not a byte, so error
		ldb ,y+			; get the byte to write
		stb ,x+			; and load it at memory x
		bra nextwritebyte	; back for more
writememoryout	clra			; clean exit
		rts

; exitmonitor - fixup return address and leave monitor

exitmonitor	lbsr parseinput		; parse hexes, filling out inputbuffer
		lda ,y+			; get the type
		cmpa #2			; is it a word?
		lbne generalerror	; validation error
		lds #STACKEND+1		; move the stack to the top
		leas -12,s		; then move it back one frame
		ldx ,y++		; sub address
		beq cleanexit		; if exit address is 0 dont modify
		stx 10,s		; before modifiying the pc in stack
cleanexit	rti			; run the usercode at that address

; shows the registers as they were when the monitor was entered

ccmsg		fcc 'CC: '
		fcb NULL
amsg		fcc '  A: '
		fcb NULL
bmsg		fcc '  B: '
		fcb NULL
dpmsg		fcc '  DP: '
		fcb NULL
xmsg		fcc '  X: '
		fcb NULL
ymsg		fcc '  Y: '
		fcb NULL
umsg		fcc '  U: '
		fcb NULL
pcmsg		fcc '  PC: '
		fcb NULL

showregisters	ldx #outputbuffer	; set output buffer

		ldy #ccmsg		; get the 'C: '
		lbsr concatstr		; concat it onto outputbuffer
		lda STACKEND+1-12	; get the register value
		lbsr bytetoaschex	; convert and concat it

		ldy #amsg		; same again
		lbsr concatstr		; ...
		lda STACKEND+1-11	; ...
		lbsr bytetoaschex	; ...

		ldy #bmsg
		lbsr concatstr
		lda STACKEND+1-10
		lbsr bytetoaschex

		ldy #dpmsg
		lbsr concatstr
		lda STACKEND+1-9
		lbsr bytetoaschex

		ldy #xmsg
		lbsr concatstr
		ldd STACKEND+1-8
		lbsr wordtoaschex

		ldy #ymsg
		lbsr concatstr
		ldd STACKEND+1-6
		lbsr wordtoaschex

		ldy #umsg
		lbsr concatstr
		ldd STACKEND+1-4
		lbsr wordtoaschex

		ldy #pcmsg
		lbsr concatstr
		ldd STACKEND+1-2
		lbsr wordtoaschex

		ldy #newlinemsg
		lbsr concatstr
		clr ,x+

		ldx #outputbuffer	; and output it
		lbsr serialputstr
		clra			; we always succeed
		rts

; shows some help text

helpmsg		fcc 'Commands:'
		fcb CR
		fcb LF
		fcc '  r : show registers'
		fcb CR
		fcb LF
		fcc '  w AAAA B1 B2 B3 ... : write to AAAA bytes B1 B2 B3 ...'
		fcb CR
		fcb LF
		fcc '  d AAAA LLLL : dump from AAAA count LLLL bytes in hex'
		fcb CR
		fcb LF
		fcc '  e EEEE : exit to user code at EEEE'
		fcb CR
		fcb LF
		fcc '  x : reset the monitor'
		fcb CR
		fcb LF
		fcc '  + SSSS WWWW RRRR : write WWWW spi bytes then read RRRR bytes'
		fcb CR
		fcb LF
		fcc '  t : show time'
		fcb CR
		fcb LF
		fcc '  u : show uptime'
		fcb CR
		fcb LF
		fcc '  o OO : output OO on I2C I/O expander port A'
		fcb CR
		fcb LF
		fcc '  c OO : output OO on the latch'
		fcb CR
		fcb LF
		fcc '  b MMMM NNNN : read 1k disk block NNNN into MMMM'
		fcb CR
		fcb LF
		fcc '  m : set 8bit ide and read mbr'
		fcb CR
		fcb LF
		fcc '  h or ? : this help'
		fcb CR
		fcb LF
		fcb CR
		fcb LF
		fcb NULL

showhelp	ldx #greetingmsg	; show the greeting
		lbsr serialputstr	; for the version number
		ldx #helpmsg		; and the help text
		lbsr serialputstr
		clra			; we always suceed
		rts

; restart the monitor (so we can flash it with 'f', most likely)

resetmonitor	ldx $fffe		; get the reset vector
		jmp ,x			; jump to it

; time

; days array - each day is 4 bytes long

days		fcc 'Sun'
		fcb NULL
		fcc 'Mon'
		fcb NULL
		fcc 'Tue'
		fcb NULL
		fcc 'Wed'
		fcb NULL
		fcc 'Thu'
		fcb NULL
		fcc 'Fri'
		fcb NULL
		fcc 'Sat'
		fcb NULL

showtime	lbsr spistart		; mark with start

		clrb
		lbsr spiwrite		; write address 0

		ldx #timeoutput
		ldy #8

showtimenext	lbsr spiread
		stb, x+
		
		leay -1,y
		bne showtimenext

		lbsr spistop		; mark with stop

		ldx #outputbuffer	; setup output buffer
		ldy #timeoutput		; setup rtc data buffer

		lda 2,y			; get hours
		lbsr bytetoaschex	; render hex into x
		lda #$3a		; ':'
		sta ,x+	
		lda 1,y			; get minutes
		lbsr bytetoaschex
		lda #$3a		; ':'
		sta ,x+
		lda 0,y			; get seconds
		lbsr bytetoaschex
		lda #$20		; space char
		sta ,x+
		clra			; add a null
		sta ,x+
		ldx #outputbuffer	; reset x for printing
		lbsr serialputstr	; print the time followed by space

		lda 3,y			; get days (1-7)
		deca			; make it into 0-6
		lsla			; multiple by 4 as each day is 4...
		lsla			; bytes including a null
		ldx #days		; setup pointer to day array
		leax a,x		; add on the offset from above
		lbsr serialputstr	; output the day

		ldx #outputbuffer	; back in the ram buffer
		lda #$20		; space char
		sta ,x+			; add it so its after the day
		lda 4,y			; get date in month
		lbsr bytetoaschex
		lda #$2f		; '/'
		sta ,x+
		lda 5,y			; get the month
		lbsr bytetoaschex
		lda #$2f		; '/'
		sta ,x+
		lda 6,y			; get the year
		lbsr bytetoaschex
		clra
		sta ,x+
		ldx #outputbuffer	; reset output buffer
		lbsr serialputstr	; output the date ( DD/MM/YY)

		ldx #newlinemsg
		lbsr serialputstr	; and add a newline

		clra
		rts		

; showuptime

showuptime	ldx #outputbuffer
		ldd uptimeh
		lbsr wordtoaschex
		ldd uptimel
		lbsr wordtoaschex
		ldy #newlinemsg
		lbsr concatstr
		clr ,x+
		ldx #outputbuffer
		lbsr serialputstr
		rts

; latchout - "c OO" outputs a byte on the "latch"

latchout	lbsr parseinput
		lda ,y+
		cmpa #1
		lbne generalerror

		lda ,y+
		sta LATCH

		clra
		rts

; spi store - "+ FFFF WWW RRR..." - writes and reads to the spi bus

spistore	lbsr parseinput		; parse hexes, filling out inputbuffer

		lda ,y+			; get the type
		cmpa #2			; word?
		lbne generalerror	; validation error
		ldu ,y++		; get the start of mpu memory

		lda, y+			; get the type
		cmpa #2			; word?
		lbne generalerror	; validation error
		ldx ,y++		; get the count of bytes to read

		lda, y+			; get the type
		cmpa #2			; word?
		lbne generalerror	; validation error
		ldy ,y			; get the count of bytes to read

		lbsr spistart		; mark with start

spistorenext	leax ,x
		beq spistoredone

		ldb ,u+			; get data to write
		lbsr spiwrite		; write it

		leax -1,x
		bra spistorenext

spistoredone
spiloadnext	leay, y
		beq spiloaddone

		lbsr spiread
		stb, u+
		
		leay -1,y

		bra spiloadnext

spiloaddone	lbsr spistop		; mark with stop

		clra
		rts

; ideidentify - print info about the device

serialnomsg	fcc 'Serial number: '
		fcb NULL
firmwarerevmsg	fcc 'Firmware revision: '
		fcb NULL
modelnomsg	fcc 'Model number: '
		fcb NULL

ideidentify	lda #$ec
		lbsr simpleidecomm

		ldx #ideidentifyblk
		lbsr idelowlevelread

		ldx #outputbuffer
		ldy #serialnomsg
		lbsr concatstr
		ldy #ideidentifyblk+20
		lda #20
		lbsr concatstrn
		ldy #newlinemsg
		lbsr concatstr
		clr ,x
		ldx #outputbuffer
		lbsr serialputstr

		ldx #outputbuffer
		ldy #firmwarerevmsg
		lbsr concatstr
		ldy #ideidentifyblk+46
		lda #8
		lbsr concatstrn
		ldy #newlinemsg
		lbsr concatstr
		clr ,x
		ldx #outputbuffer
		lbsr serialputstr

		ldx #outputbuffer
		ldy #modelnomsg
		lbsr concatstr
		ldy #ideidentifyblk+54
		lda #40
		lbsr concatstrn
		ldy #newlinemsg
		lbsr concatstr
		clr ,x+
		ldx #outputbuffer
		lbsr serialputstr

		clra
		rts

; idereadsector - < L0 L1 NN MMMM - read NN sectors from L0 L1 into MMMM

idereadsector	lbsr parseinput

		lda ,y+			; get the type
		cmpa #1			; word?
		lbne generalerror	; validation error
		lda ,y+
		sta IDELBA0

		lda ,y+			; get the type
		cmpa #1			; word?
		lbne generalerror	; validation error
		lda ,y+
		sta IDELBA1

		clr IDELBA2
		clr IDELBA3

		lda ,y+			; get the type
		cmpa #1			; word?
		lbne generalerror	; validation error
		lda ,y+		
		sta IDECOUNT

		lda ,y+
		cmpa #2
		lbne generalerror
		ldx, y++

		lda #$20
		lbsr simpleidecomm

readsectorloop	lbsr idelowlevelread

		lda IDECOUNT
		bne readsectorloop

		clra
		rts

; readblock - b MMMM NNNN - read 1k block NNNN into MMMM

readblock	lbsr parseinput

		lda ,y+			; get the type
		cmpa #2			; word?
		lbne generalerror	; validation error
		ldx ,y++

		lda ,y+			; get the type
		cmpa #2			; word?
		lbne generalerror	; validation error
		ldy ,y++

		lbsr readfsblock

		clra
	
		rts

; idemount - m - sets 8 bit mode and reads the mbr

partstartmsg	fcc 'Partition starts at: '
		fcb NULL
nombrmsg	fcc 'No MBR found, assuming single partition'
		fcb CR
		fcb LF
		fcb NULL

idemount	lda #$01		; 8 bit enable
		sta IDEFEATURES

		lda #$ef		; set features
		lbsr simpleidecomm
		lbsr idewaitnotbusy

		clr IDELBA0
		clr IDELBA1
		clr IDELBA2
		clr IDELBA3

		lda #1
		sta IDECOUNT

		lda #$20
		lbsr simpleidecomm

		ldx #idembrblk
		lbsr idelowlevelread

		ldd idembrblk+$01fe
		exg a,b
		cmpd #$aa55
		beq idemountmbr

		ldx #nombrmsg
		lbsr serialputstr

		clrd
		std firstpartsects

		rts

idemountmbr	ldx #outputbuffer
		ldy #partstartmsg
		lbsr concatstr

		ldd idembrblk+$01be+$08
		exg a,b
		std firstpartsects
		lbsr wordtoaschex

		ldy #newlinemsg
		lbsr concatstr
		clr ,x+

		ldx #outputbuffer
		lbsr serialputstr

		rts

;;; END OF HIGH LEVEL COMMANDS

;;; IDE

; run the trivial command in 'a', assuming other params are setup

simpleidecomm	ldb #%11100000
		stb IDEHEADS
		sta IDECOMMAND
		clra
		rts

idewaitnotbusy	lda IDESTATUS
		anda #$80
		bne idewaitnotbusy
		rts

idewaitfordata	lda IDESTATUS
		anda #$08
		beq idewaitfordata
		rts

idelowlevelread	ldy #512
		lbsr idewaitnotbusy
		lbsr idewaitfordata
readbyteloop	lda IDEDATA
		sta ,x+
		leay -1,y
		bne readbyteloop
		rts

;;; FS

; readfsblock - reads 1k block at y into block buffer at x

readfsblock	tfr y,d
		lslb
		lsla			; multiple x by 2->sectors
		addd firstpartsects	; add sector offset for the partition
		
		stb IDELBA0
		sta IDELBA1
		clr IDELBA2
		clr IDELBA3

		lda #2
		sta IDECOUNT

		lda #$20
		lbsr simpleidecomm

		lbsr idelowlevelread
		lbsr idelowlevelread

		rts

;;; VIA

viainit		clra
		sta PORTA6522
		ora #SS
		ora #SCLK
		ora #MOSI
		sta DDRA6522
		rts

;;; SPI low level routines

spistart	lda #SS			; assert chip select on 1305
		sta PORTA6522
		nop			; wait for read

		rts

spistop		clra			; deassert chip select
		sta PORTA6522
		nop			; pause

		rts

; spiwrite - send the byte in b

spiwrite

; bit 7

		lda #SS			; ensure chip select
		lslb			; move the bit to send into carry
		adca #0			; add carry so low bit is set for out
		sta PORTA6522		; output
		ora #SCLK		; assert the clock by oring it in
		sta PORTA6522		; output
		nop			; wait a bit
		eora #SCLK		; clear the clock
		sta PORTA6522
		nop			; output and wait

; bit 6

		lda #SS
		lslb
		adca #0
		sta PORTA6522
		ora #SCLK
		sta PORTA6522
		nop
		eora #SCLK
		sta PORTA6522
		nop

; bit 5

		lda #SS
		lslb
		adca #0
		sta PORTA6522
		ora #SCLK
		sta PORTA6522
		nop
		eora #SCLK
		sta PORTA6522
		nop

; bit 4

		lda #SS
		lslb
		adca #0
		sta PORTA6522
		ora #SCLK
		sta PORTA6522
		nop
		eora #SCLK
		sta PORTA6522
		nop

; bit 3

		lda #SS
		lslb
		adca #0
		sta PORTA6522
		ora #SCLK
		sta PORTA6522
		nop
		eora #SCLK
		sta PORTA6522
		nop

; bit 2

		lda #SS
		lslb
		adca #0
		sta PORTA6522
		ora #SCLK
		sta PORTA6522
		nop
		eora #SCLK
		sta PORTA6522
		nop

; bit 1

		lda #SS
		lslb
		adca #0
		sta PORTA6522
		ora #SCLK
		sta PORTA6522
		nop
		eora #SCLK
		sta PORTA6522
		nop

; bit 0

		lda #SS
		lslb
		adca #0
		sta PORTA6522
		ora #SCLK
		sta PORTA6522
		nop
		eora #SCLK
		sta PORTA6522
		nop

		rts

spiread		clrb

; bit 7

		lda #SS
		ora #SCLK
		sta PORTA6522
		nop
		lda PORTA6522
		rola
		rolb
		lda #SS
		sta PORTA6522
		nop

; bit 6

		lda #SS
		ora #SCLK
		sta PORTA6522
		nop
		lda PORTA6522
		rola
		rolb
		lda #SS
		sta PORTA6522
		nop

; bit 5

		lda #SS
		ora #SCLK
		sta PORTA6522
		nop
		lda PORTA6522
		rola
		rolb
		lda #SS
		sta PORTA6522
		nop

; bit 4

		lda #SS
		ora #SCLK
		sta PORTA6522
		nop
		lda PORTA6522
		rola
		rolb
		lda #SS
		sta PORTA6522
		nop

; bit 3

		lda #SS
		ora #SCLK
		sta PORTA6522
		nop
		lda PORTA6522
		rola
		rolb
		lda #SS
		sta PORTA6522
		nop

; bit 2

		lda #SS
		ora #SCLK
		sta PORTA6522
		nop
		lda PORTA6522
		rola
		rolb
		lda #SS
		sta PORTA6522
		nop

; bit 1

		lda #SS
		ora #SCLK
		sta PORTA6522
		nop
		lda PORTA6522
		rola
		rolb
		lda #SS
		sta PORTA6522
		nop

; bit 0

		lda #SS
		ora #SCLK
		sta PORTA6522
		nop
		lda PORTA6522
		rola
		rolb
		lda #SS
		sta PORTA6522
		nop

		rts



;;; SERIAL PORT ;;;

; serial port setup

serialinit	lda #%00000011		; master reset
		sta SERIALCR
		; divider (=16), databits (=8n1), no rts and no interrupts
		lda #%00010101
		sta SERIALCR
		rts

; put the char in a, returning when its sent - corrupts b

serialputchar	ldb SERIALSR
		andb #%00000010		; transmit empty
		beq serialputchar	; wait for port to be idle
		sta SERIALTX		; output the char
		rts

; puts the null terminated string pointed to by x

serialputstr	lda ,x+			; get the next char
		beq serialputstrout	; null found, bomb out
		bsr serialputchar	; output the character
		bra serialputstr	; more chars
serialputstrout	rts

; serialgetchar - gets a char, putting it in a

serialgetchar 	lda SERIALSR		; get status
		anda #%00000001		; input empty?
		beq serialgetchar	; go back and look again
		lda SERIALRX		; get the char into a
serialgetcharo	rts
		
; serialgetstr - gets a line, upto a cr, filling x as we go

serialgetstr	bsr serialgetchar	; get a char in a
		cmpa #CR		; cr?
		beq serialgetstrout	; if it is, then out
		cmpa #LF		; lf?
		beq serialgetstrout	; if it is, then out
		bsr serialputchar	; echo it
		sta ,x+			; add it to string
		bra serialgetstr	; get more
serialgetstrout	clr ,x+			; add a null
		rts

;;; STRINGS ;;;

; aschextonib - convert a char on x to a low nibble in a

aschextonib	lda ,x+			; get the charater
		suba #$30		; subtract '0'
		cmpa #$10		; less then 9?
		blo aschextonibout	; yes? we are done
		suba #$07		; no? subtract 'A'-'9'
		cmpa #$10		; less then 16?
		blo aschextonibout	; was uppercase
		suba #$20
aschextonibout	rts

; aschextobyte - convert two characters on x to a byte in a

aschextobyte	leas -1,s		; make room on stack for 1 temp byte
		bsr aschextonib		; convert the low nibble
		lsla			; make it the high nibble
		lsla			; ..
		lsla			; ..
		lsla			; ..
		sta ,s			; save it on the stack
		bsr aschextonib		; convert the real low nibble
		ora ,s			; combine it with the high nibble
		leas 1,s		; shrink the stack again
		rts

; aschextowrd - convert four characters on x to a word in d

aschextoword	bsr aschextobyte	; convert the first byte in the string
		tfr a,b			; move it asside
		bsr aschextobyte	; convert the second byte
		exg a,b			; swap the bytes
		rts			; d is now the word

; parse a stream of ascii hex into the u stack

parseinput	ldx #inputbuffer+1	; point at the inputbuffer
		ldy #parambuffer	; setup parser location
nextparseinput	lda ,x			; check for an initiial null
		beq parseinputout	; null? out we go
		bsr skipspaces		; skip spaces
		lda 2,x			; get the next but one char
		beq parsebyte		; null? it's a byte
		cmpa #$20		; space
		beq parsebyte		; yes? it's a byte
		bra parseword		; must be a word
parsebyte	lda #1			; code 1 for bytes
		sta ,y+			; add it into the stream
		bsr aschextobyte	; yes? this pair must be a byte
		sta ,y+			; save it in u
		bra nextparseinput		; look for more
parseword	lda #2			; code 2 for words
		sta ,y+			; add it in to the stream
		bsr aschextoword	; if we get here it must be a word
		std ,y++		; save the word in u
		bra nextparseinput
parseinputout	clr ,y+			; null ender
		ldy #parambuffer	; reset back for the caller
		rts

; nibtoaschex - convert a low nibble in a to a character in x, advancing it

nibtoaschex	anda #$0f		; mask out the high nibble
		adda #$30		; add '0'
		cmpa #$39		; see if we are past '9'
		ble nibtoaschexout	; no? number then, so we're done
		adda #$07		; yes? letter then, add 'A'-'9'
nibtoaschexout	sta ,x+			; add it to the string
		rts		

; bytetoaschex - convert a byte in a to two characters in x, advancing it
		
bytetoaschex	pshs a			; save original input byte
		lsra			; move high nibble into low nibble
		lsra			; ..
		lsra			; ..
		lsra			; ..
		bsr nibtoaschex		; convert the low nibble
		puls a			; get the original input back
		bsr nibtoaschex		; convert the high nibble
		rts

; wordtoaschex - convert a word in d to four characters in x, advancing it

wordtoaschex	pshs b			; save low byte
		bsr bytetoaschex	; output high byte
		puls a			; restore low byte
		bsr bytetoaschex	; and output low byte
		rts

; jump x across spaces

skipspaces	lda ,x+			; skip a space
		cmpa #$20		; is it a space?
		beq skipspaces		; yes? then go back and look for more
		leax -1,x		; back 1
		rts

; printableasc - converts non printables to . in a

printableasc	cmpa #$20		; compare with space
		blo printabletodot	; lower? it must be a unprintable
		cmpa #$7e		; compare with the end char
		bhi printabletodot	; higher? it must be unprintable
		rts			; if not, leave it alone
printabletodot	lda #$2e		; otherwise flatten it to a dot
		rts

; concatstr - add string y to string x, not copying the null

concatstr	lda ,y+			; get the char in y
		beq concatstrout	; if its a null then finish
		sta ,x+			; otherwise add it to x
		bra concatstr		; go back for more
concatstrout	rts

; concatstrn - add a chars of y to x, not ocpying the null

concatstrn	ldb ,y+
		stb ,x+
		deca
		beq concatstrnout
		bra concatstrn
concatstrnout	rts

;;; MISC ;;;

; delay by y - subroutine

delay		leay -1,y		; decrement y
		bne delay		; not zero? do it again
		rts
; flasher

flasher		ldx #flashreadymsg	; tell other end it can send now
		lbsr serialputstr

; read 64bytes from the serial port into ram

		ldy #ROMSTART		; setup the counter into rom
inflashblk	ldx #flashblock		; this is the block in ram we...
		ldb #64			; are copying into
inflash		lbsr serialgetchar	; get the byte from the port
		sta ,x+			; store it
		decb			; we store 64bytes
		bne inflash		; back to the next byte

; then write them into rom

		ldx #flashblock		; after we have a block
		ldb #64			; of 64 bytes
outflash	lda ,x+			; get the byte from ram
		sta ,y+			; and write it into the rom
		decb			; reduce byte counter
		bne outflash		; back for more if non zero

; circa 10ms delay between blocks

		ldx #12000		; setup delay counter
flashdelayloop	leax -1,x		; dey
		bne flashdelayloop

; tell the uploader that we have written the block, and it can send the
; next one

		lda #$23		; '#'
		lbsr serialputchar	; send the char
		cmpy #ROMEND+1		; see if we are the end of rom
		bne inflashblk		; back to the next block

; send the content of the rom back, so the sender knows what was written -
; we can't do anything if it didn't write, but at least we know

		ldy #ROMSTART		; back to the start
verflash	lda ,y+			; get the byte
		lbsr serialputchar	; output it
		cmpy #ROMEND+1
		bne verflash

; we could in theory try again but good or bad, do a reset on the new
; reset vector
		
		ldx $fffe		; load the new reset vector
		jmp ,x			; jump to it
